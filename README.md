Firstly, we implemented two counters in our program, with both being initialized to zero. One to contain the number of tasks to be handled and the other to contain the number of tasks to be dispatched. Afterwards, we created a struct labelled Task, which is split into two components: an integer variable to label the priority number and a void pointer function that stores the function name. We then spawned two queues from this structure, the first is a normal priority queue (QueTask) whereas the other is a DelayedQueue that contains tasks requesting a rerun. Following this, we began implementing three functions (we could go on forever), labelled TaskA, TaskB and TaskC. These are void functions that only serve the purpose of printing out a declaration of the task's execution (i.e. "This is TaskA"). The main function in our program, QueTask, is void and handles two parameters: the task's name and its priority number. We have two temp variables constructed for each of these two parameters, both initialized to zero.  

The aforementioned Counter (the first of two) is utilized to count the number of tasks within the queue. If the queue is found to be empty, the first task and its priority value are inserted into the first position (zero) and the counter is incremented. Else if the queue is non-empty, the task and its priority are implemented at the counter’s position, then it is incremented. This incrementation is repeated as long as QueTask calls are coming in. A for loop is then called in order to perform sorting of the queue’s elements based on their priorities. Whenever a task’s inserted, the sorting algorithm is called to check for the new entrant and sort him in the queue based on his priority.   If a new entrant has a priority lower than that within the queue, they are swapped and the rest of tasks are shifted in order to maintain hierarchy. We also routinely check that the queue task’s value at position [j] (the position used for in-queue task comparisons) is NOT zero. That’s because the queue can be initialized as fully null, so comparisons with a zero value are considered rubbish/redundant.

We then implemented a void function labelled Dispatch(). Within this function, the dispatch global variable is checked. If set as zero, the highest-priority task in the queue is dispatched to be run. Following its first execution, it prints which task is being excuted on renode. After that, in the infinite while loop in the main function it keeps recalling the Dispatch function to run the following task and finally increment the dispatch counter. The void initialized function [Init()] gets the queued tasks and their priority numbers. This leaves our Main segment with only performing two missions: initializing (calling Init() ) and calling Dispatch().  Our implementation of the ReRunMe requirement which inputs into the DelayedQueue does not behave correctly and the dispatched tasks are continuously being dispatched in a manner similar to an infinite loop. We also modified the tick as [divide by ten] in order to be visibly measured and not too rapid. 





Done By: Omar Radwan - 900153452 , Ahmed Ibrahim 900160265 and Mohamed Tarek 900153171
